#!/bin/bash
# Author of the idea: Tomas M. <http://www.linux-live.org>
# Author: crims0n <https://minios.dev>

VERSION="1.7"
SYSTEMNAME="MiniOS"
export TEXTDOMAIN="minios-tools"
TEMP=/tmp/minios.iso.$$
REGEX='^$'
MODULES=()
PWD="$(pwd)"
VERBOSITY_LEVEL=0
MENU_TYPE="multilang"
TEMP_GRUB_CONFIG=""

# Detect initramfs type and set paths
if [ -d "/run/initramfs/memory" ]; then
    # livekit initramfs
    SOURCE="/run/initramfs/memory"
elif [ -d "/lib/live/mount" ]; then
    # dracut initramfs
    SOURCE="/lib/live/mount"
fi

help() {
    echo "$(gettext "Usage"): $(basename $0) [OPTIONS]... [MODULE.SB]..."
    echo "$(gettext "Generate MiniOS ISO image, adding specified modules.")"
    echo ""
    echo "$(gettext "Options"):"
    echo "  -e, --exclude REGEX   $(gettext "Exclude any existing path or file matching REGEX")"
    echo "  -n, --name NAME       $(gettext "Specify output ISO filename (default"): minios-YYYYMMDD_HHMM.iso)"
    echo "      --menu TYPE       $(gettext "Set menu type: multilang or language code")"
    echo "                        $(gettext "  multilang: menu with language selection (default)")"
    echo "                        $(gettext "  language: specific language (en_US, ru_RU, de_DE, etc.)")"
    echo "      --help            $(gettext "Display this help and exit")"
    echo "      --version         $(gettext "Display version information and exit")"
    echo ""
    echo "$(gettext "Examples"):"
    echo "  # $(gettext "Create basic MiniOS ISO with current system:")"
    echo "  $(basename $0)"
    echo "  # $(gettext "Create ISO with custom filename:")"
    echo "  $(basename $0) --name my_minios.iso"
    echo "  # $(gettext "Create ISO excluding specific modules:")"
    echo "  $(basename $0) --exclude 'firefox|libreoffice' --name minios_slim.iso"
    echo "  # $(gettext "Create minimal text-mode ISO:")"
    echo "  $(basename $0) --exclude 'desktop|xorg|apps' --name minios_minimal.iso"
    echo "  # $(gettext "Create ISO with additional modules:")"
    echo "  $(basename $0) extra_module.sb another_module.sb"
    echo "  # $(gettext "Create Russian localized ISO:")"
    echo "  $(basename $0) --menu ru_RU --name minios_ru.iso"
    exit 0
}

brief_help() {
    echo "$(gettext "Usage"): $(basename $0) [OPTIONS]... [MODULE.SB]..."
    echo "$(gettext "Try") '$(basename $0) --help' $(gettext "for more information.")"
    exit 1
}

version() {
    echo "$(basename $0) $VERSION"
    exit 0
}

console_colors() {
    RED=$'\e[31m'
    GREEN=$'\e[32m'
    YELLOW=$'\e[33m'
    CYAN=$'\e[36m'

    BOLD=$'\e[1m'

    ENDCOLOR=$'\e[0m'
}

error() {
    local MESSAGE="${1-}"
    if [ "$OUTPUT_MODE" = "console" ]; then
        echo -e "${BOLD}${RED}E:${ENDCOLOR} $MESSAGE" >&2
    else
        echo "E: $MESSAGE" >&2
    fi
}

warning() {
    local MESSAGE="${1-}"
    if [ "$OUTPUT_MODE" = "console" ]; then
        echo -e "${BOLD}${YELLOW}W:${ENDCOLOR} $MESSAGE"
    else
        echo "W: $MESSAGE"
    fi
}

information() {
    local MESSAGE="${1-}"
    if [ "$OUTPUT_MODE" = "console" ]; then
        echo -e "${BOLD}${CYAN}I:${ENDCOLOR} $MESSAGE"
    else
        echo "I: $MESSAGE"
    fi
}

spinner() {
    local PID="${1}"
    local MSG="${2}"
    local XTRACE_WAS_SET=false
    case "$-" in
    *x*)
        XTRACE_WAS_SET=true
        set +x
        ;;
    esac

    local DELAY=0.1
    local SPINSTR='|/-\\'
    while [ -d "/proc/${PID}" ]; do
        for ((i = 0; i < ${#SPINSTR}; i++)); do
            printf "\r${BOLD}${CYAN}I:${ENDCOLOR} ${MSG} [${CYAN}${SPINSTR:$i:1}${ENDCOLOR}]"
            sleep "${DELAY}"
        done
    done
    printf "\r${BOLD}${CYAN}I:${ENDCOLOR} ${MSG} [${GREEN}done${ENDCOLOR}]$(tput el)\n"

    if ${XTRACE_WAS_SET}; then
        set -x
    fi
}

run_with_spinner() {
    local MSG="$1"
    shift
    if [ "${VERBOSITY_LEVEL}" -ge 1 ]; then
        "$@"
    else
        "$@" >/dev/null 2>&1 &
        local CMD_PID="$!"
        spinner "${CMD_PID}" "${MSG}"
        wait "${CMD_PID}"
    fi
}

# Function to parse .po files for translations
parse_po_file() {
    local PO_FILE="$1"
    local TEMP_FILE=$(mktemp)

    if [ ! -e "$PO_FILE" ]; then
        rm -f "$TEMP_FILE"
        return 1
    fi

    # Extract msgid and msgstr pairs, handling multiline strings
    awk '
    BEGIN { msgid = ""; msgstr = ""; in_msgid = 0; in_msgstr = 0; }

    /^msgid / {
        if (msgid != "" && msgstr != "") {
            # Remove quotes and unescape
            gsub(/^"|"$/, "", msgid); gsub(/\\n/, "\n", msgid); gsub(/\\"/, "\"", msgid);
            gsub(/^"|"$/, "", msgstr); gsub(/\\n/, "\n", msgstr); gsub(/\\"/, "\"", msgstr);
            if (msgid != "" && msgstr != "") print msgid "|||" msgstr;
        }
        msgid = substr($0, 7); in_msgid = 1; in_msgstr = 0;
    }

    /^msgstr / {
        msgstr = substr($0, 8); in_msgstr = 1; in_msgid = 0;
    }

    /^"/ {
        if (in_msgid) msgid = msgid substr($0, 2, length($0) - 2);
        else if (in_msgstr) msgstr = msgstr substr($0, 2, length($0) - 2);
    }

    /^$/ { in_msgid = 0; in_msgstr = 0; }

    END {
        if (msgid != "" && msgstr != "") {
            gsub(/^"|"$/, "", msgid); gsub(/\\n/, "\n", msgid); gsub(/\\"/, "\"", msgid);
            gsub(/^"|"$/, "", msgstr); gsub(/\\n/, "\n", msgstr); gsub(/\\"/, "\"", msgstr);
            if (msgid != "" && msgstr != "") print msgid "|||" msgstr;
        }
    }
    ' "$PO_FILE" >"$TEMP_FILE"

    if [ -s "$TEMP_FILE" ]; then
        echo "$TEMP_FILE"
        return 0
    else
        rm -f "$TEMP_FILE"
        return 1
    fi
}

# Function to get translation from parsed po file
get_translation() {
    local TRANSLATIONS_FILE="$1"
    local MSGID="$2"

    if [ ! -e "$TRANSLATIONS_FILE" ]; then
        echo "$MSGID"
        return
    fi

    local RESULT=$(grep -F "${MSGID}|||" "$TRANSLATIONS_FILE" 2>/dev/null | head -n1 | cut -d'|' -f4-)
    if [ -n "$RESULT" ]; then
        echo "$RESULT"
    else
        echo "$MSGID"
    fi
}

# Function to generate localized GRUB config
generate_localized_grub_config() {
    local GRUB_DIR="$1"
    local LANG_CODE="$2"
    local OUTPUT_FILE="$3"

    # Parse po file for the language
    local PO_FILE="$GRUB_DIR/po/${LANG_CODE}.po"
    local TRANSLATIONS_FILE

    if ! TRANSLATIONS_FILE=$(parse_po_file "$PO_FILE"); then
        warning "$(gettext "No translations found for $LANG_CODE, using English fallback")"
        return 1
    fi

    # Get template config
    local TEMPLATE_CFG="$GRUB_DIR/grub.template.cfg"
    if [ ! -e "$TEMPLATE_CFG" ]; then
        error "$(gettext "grub.template.cfg template not found")"
        rm -f "$TRANSLATIONS_FILE"
        return 1
    fi

    # Read template content
    local TEMPLATE_CONTENT=$(cat "$TEMPLATE_CFG")
    local LOCALIZED_CONTENT="$TEMPLATE_CONTENT"

    # Define menu entries to translate
    local ENGLISH_TEXTS=(
        "Resume previous session"
        "Start a new session"
        "Choose session during startup"
        "Fresh start"
        "Copy to RAM"
        "Loading kernel and ramdisk..."
        "MiniOS"
    )

    local VAR_NAMES=(
        "resume"
        "newsession"
        "choosesession"
        "freshstart"
        "copyram"
        "loading"
        "OS"
    )

    # Replace English menu text with localized versions
    for i in "${!ENGLISH_TEXTS[@]}"; do
        local ENGLISH_TEXT="${ENGLISH_TEXTS[$i]}"
        local VAR_NAME="${VAR_NAMES[$i]}"
        local LOCALIZED_TEXT=$(get_translation "$TRANSLATIONS_FILE" "$ENGLISH_TEXT")

        if [ "$LOCALIZED_TEXT" != "$ENGLISH_TEXT" ]; then
            # Replace menuentry labels
            LOCALIZED_CONTENT=$(echo "$LOCALIZED_CONTENT" | sed "s/menuentry \"$ENGLISH_TEXT\"/menuentry \"$LOCALIZED_TEXT\"/g")
            # Replace variable assignments
            LOCALIZED_CONTENT=$(echo "$LOCALIZED_CONTENT" | sed "s/set ${VAR_NAME}=\"$ENGLISH_TEXT\"/set ${VAR_NAME}=\"$LOCALIZED_TEXT\"/g")
        fi
    done

    # Set localized theme if available
    local THEME_PATH="/minios/boot/grub/minios-theme/theme_${LANG_CODE}.txt"
    if [ -e "$GRUB_DIR/minios-theme/theme_${LANG_CODE}.txt" ]; then
        # Replace theme setting with localized version
        LOCALIZED_CONTENT=$(echo "$LOCALIZED_CONTENT" | sed "s|set theme=/minios/boot/grub/minios-theme/theme\.txt|set theme=$THEME_PATH|g")
    fi

    # Write localized config
    echo "$LOCALIZED_CONTENT" >"$OUTPUT_FILE"

    # Cleanup
    rm -f "$TRANSLATIONS_FILE"
    return 0
}

console_colors

while [ "$#" -gt 0 ]; do
    case "$1" in
    -e | --exclude)
        REGEX="$2"
        shift 2
        ;;
    -n | --name)
        TARGET="$(readlink -f "$2")"
        shift 2
        ;;
    --menu)
        case "$2" in
        multilang | en_US | ru_RU | de_DE | es_ES | it_IT | id_ID | pt_BR | pt_PT | fr_FR)
            MENU_TYPE="$2"
            ;;
        *)
            error "$(gettext "Invalid menu type: $2. Valid types: multilang or language codes (en_US, ru_RU, de_DE, es_ES, it_IT, id_ID, pt_BR, pt_PT, fr_FR)")"
            exit 1
            ;;
        esac
        shift 2
        ;;
    --help)
        help
        ;;
    --version)
        version
        ;;
    *) # unknown option
        if [[ $1 == -* ]]; then
            brief_help
        elif [ -e "$1" ]; then
            MODULES+=("$(readlink -f "$1")")
            shift
        else
            error "$(gettext "Unknown argument: $1")"
            brief_help
        fi
        ;;
    esac
done

TARGET=${TARGET:-"${PWD}/minios-$(date +%Y%m%d_%H%M).iso"}

# Function to detect bootloader type based on files present in the boot directory
detect_bootloader_type() {
    local MINIOS_SOURCE="$1"

    if [ ! -d "$MINIOS_SOURCE" ]; then
        echo "syslinux-grub"
        return
    fi

    local BOOT_DIR="$MINIOS_SOURCE/boot"
    if [ ! -d "$BOOT_DIR" ]; then
        echo "syslinux-grub"
        return
    fi

    # Check for SYSLINUX directory
    local SYSLINUX_DIR="$BOOT_DIR/syslinux"
    local HAS_SYSLINUX=false
    if [ -d "$SYSLINUX_DIR" ]; then
        HAS_SYSLINUX=true
    fi

    # Check for GRUB BIOS components
    local GRUB_BIOS_DIR="$BOOT_DIR/grub/i386-pc"
    local HAS_GRUB_BIOS=false
    if [ -d "$GRUB_BIOS_DIR" ]; then
        HAS_GRUB_BIOS=true
    fi

    # Determine bootloader type based on what's present
    if [ "$HAS_SYSLINUX" = "true" ] && [ "$HAS_GRUB_BIOS" = "true" ]; then
        echo "syslinux-grub"
    elif [ "$HAS_SYSLINUX" = "true" ] && [ "$HAS_GRUB_BIOS" = "false" ]; then
        echo "syslinux-native"
    elif [ "$HAS_SYSLINUX" = "false" ] && [ "$HAS_GRUB_BIOS" = "true" ]; then
        echo "grub-only"
    else
        # Fallback
        echo "syslinux-grub"
    fi
}

# Find MiniOS source directory
find_minios_source() {
    local CANDIDATES=(
        "$SOURCE/data/minios"
        "$SOURCE/iso/minios"
        "$SOURCE/toram"
        "$SOURCE/data/from/0/minios"
    )

    for CANDIDATE in "${CANDIDATES[@]}"; do
        if [ -d "$CANDIDATE" ]; then
            local BOOT_DIR="$CANDIDATE/boot"
            if [ -d "$BOOT_DIR" ]; then
                # Check for generic vmlinuz file
                if [ -e "$BOOT_DIR/vmlinuz" ]; then
                    echo "$CANDIDATE"
                    return
                fi

                # Check for any vmlinuz* files
                if ls "$BOOT_DIR"/vmlinuz* >/dev/null 2>&1; then
                    # Also check for initramfs files
                    if ls "$BOOT_DIR"/initrfs* >/dev/null 2>&1 || ls "$BOOT_DIR"/initrd* >/dev/null 2>&1; then
                        echo "$CANDIDATE"
                        return
                    fi
                fi
            fi
        fi
    done

    return 1
}

MINIOS=$(find_minios_source)

if [ "$MINIOS" = "" ]; then
    error "$(gettext "Cannot find MiniOS source directory with boot files")"
    exit 2
fi

# Detect bootloader type automatically
BOOTLOADER_TYPE=$(detect_bootloader_type "$MINIOS")
information "$(gettext "Detected bootloader type"): $BOOTLOADER_TYPE"

echo $SYSTEMNAME >/tmp/info

# Check required files based on detected bootloader type
case "$BOOTLOADER_TYPE" in
"grub-only")
    REQUIRED_FILES=(
        "$MINIOS/boot/grub/i386-pc/eltorito.img"
        "$MINIOS/boot/grub/i386-pc/boot_hybrid.img"
        "$MINIOS/boot/grub/efi64.img"
        "$MINIOS/boot/grub/efi32.img"
        "$MINIOS/boot/grub/grub.cfg"
    )
    ;;
"syslinux-native")
    REQUIRED_FILES=(
        "$MINIOS/boot/syslinux/isolinux.bin"
        "$MINIOS/boot/syslinux/isohdpfx.bin"
        "$MINIOS/boot/syslinux/syslinux.cfg"
        "$MINIOS/boot/grub/efi64.img"
        "$MINIOS/boot/grub/efi32.img"
    )
    ;;
"syslinux-grub")
    REQUIRED_FILES=(
        "$MINIOS/boot/syslinux/isolinux.bin"
        "$MINIOS/boot/syslinux/isohdpfx.bin"
        "$MINIOS/boot/syslinux/syslinux.cfg"
        "$MINIOS/boot/grub/efi64.img"
        "$MINIOS/boot/grub/efi32.img"
        "$MINIOS/boot/grub/grub.cfg"
    )
    ;;
*)
    error "$(gettext "Unknown bootloader type"): $BOOTLOADER_TYPE"
    error "$(gettext "Valid types: grub-only, syslinux-native, syslinux-grub")"
    exit 2
    ;;
esac

for FILE in "${REQUIRED_FILES[@]}"; do
    if [ ! -e "$FILE" ]; then
        error "$(gettext "Required file not found: $FILE")"
        information "$(gettext "If you loaded the system into RAM, use 'toram=full' in the kernel parameters.")"
        exit 2
    fi
done

# Create compatibility symlinks for Ventoy if NAMED_BOOT_FILES is used
if [ -d "$MINIOS/boot" ]; then
    cd "$MINIOS/boot"
    # Check if we have versioned boot files (NAMED_BOOT_FILES=true)
    VERSIONED_VMLINUZ=$(ls vmlinuz-* 2>/dev/null | head -n 1)
    VERSIONED_INITRFS=$(ls initrfs-*.img 2>/dev/null | head -n 1)

    if [ -n "$VERSIONED_VMLINUZ" ] && [ -n "$VERSIONED_INITRFS" ]; then
        # Remove old compatibility links if they exist
        [ -L "vmlinuz" ] && rm -f "vmlinuz"
        [ -L "initrfs.img" ] && rm -f "initrfs.img"

        # Create new compatibility symlinks for Ventoy
        ln -sf "$VERSIONED_VMLINUZ" "vmlinuz"
        ln -sf "$VERSIONED_INITRFS" "initrfs.img"

        information "$(gettext "Created Ventoy compatibility symlinks:")"
        information "  vmlinuz -> $VERSIONED_VMLINUZ"
        information "  initrfs.img -> $VERSIONED_INITRFS"
    fi
    cd - >/dev/null
fi

GRAFT=$(
    cd "$MINIOS"
    find . -type f | sed -r "s:^[.]/::" | egrep -v "^changes/" | egrep -v "$REGEX" | while read LINE; do
        echo "minios/$LINE=$MINIOS/$LINE"
    done
    cd "$MINIOS/boot/EFI"
    find . -type f | sed -r "s:^[.]/::" | egrep -v "$REGEX" | while read LINE; do
        echo "EFI/$LINE=$MINIOS/boot/EFI/$LINE"
    done
    echo ".disk/info=/tmp/info"
    echo "minios/config.conf=/etc/live/config.conf"
)

# Configure menu based on menu type
# All translations and help files are always included, we only switch main configs
case "$MENU_TYPE" in
multilang)
    # Use multilingual menu with language selection
    information "$(gettext "Using multilingual menu")"
    if [ -e "$MINIOS/boot/grub/grub.multilang.cfg" ]; then
        GRAFT=$(echo "$GRAFT" | sed "s|minios/boot/grub/grub.cfg=$MINIOS/boot/grub/grub.cfg|minios/boot/grub/grub.cfg=$MINIOS/boot/grub/grub.multilang.cfg|")
    fi

    # For SYSLINUX native mode, use multilingual configuration
    if [[ "$BOOTLOADER_TYPE" == "syslinux-native" ]]; then
        if [ -e "$MINIOS/boot/syslinux/syslinux.multilang.cfg" ]; then
            information "$(gettext "Using multilingual SYSLINUX configuration")"
            GRAFT=$(echo "$GRAFT" | sed "s|minios/boot/syslinux/syslinux\.cfg=$MINIOS/boot/syslinux/syslinux\.cfg|minios/boot/syslinux/syslinux.cfg=$MINIOS/boot/syslinux/syslinux.multilang.cfg|")
        fi
    fi
    ;;
en_US | ru_RU | de_DE | es_ES | it_IT | id_ID | pt_BR | pt_PT | fr_FR)
    # Generate localized configurations
    information "$(gettext "Configuring localized menu for"): $MENU_TYPE"

    # Generate localized GRUB configuration
    TEMP_GRUB_CONFIG=$(mktemp --suffix=.cfg)
    if generate_localized_grub_config "$MINIOS/boot/grub" "$MENU_TYPE" "$TEMP_GRUB_CONFIG"; then
        information "$(gettext "Generated localized GRUB menu for"): $MENU_TYPE"
        GRAFT=$(echo "$GRAFT" | sed "s|minios/boot/grub/grub.cfg=$MINIOS/boot/grub/grub.cfg|minios/boot/grub/grub.cfg=$TEMP_GRUB_CONFIG|")
    else
        # Fallback to English if localized generation failed
        warning "$(gettext "Failed to generate localized GRUB config, falling back to English")"
        TEMP_GRUB_CONFIG=$(mktemp --suffix=.cfg)
        if generate_localized_grub_config "$MINIOS/boot/grub" "en_US" "$TEMP_GRUB_CONFIG"; then
            GRAFT=$(echo "$GRAFT" | sed "s|minios/boot/grub/grub.cfg=$MINIOS/boot/grub/grub.cfg|minios/boot/grub/grub.cfg=$TEMP_GRUB_CONFIG|")
        fi
    fi

    # Handle SYSLINUX configuration for syslinux-native mode
    if [[ "$BOOTLOADER_TYPE" == "syslinux-native" ]]; then
        # Use existing localized SYSLINUX configuration
        if [ -d "$MINIOS/boot/syslinux/lang" ]; then
            local LOCALIZED_CFG="$MINIOS/boot/syslinux/lang/${MENU_TYPE}.cfg"
            if [ -f "$LOCALIZED_CFG" ]; then
                information "$(gettext "Using localized SYSLINUX configuration for"): $MENU_TYPE"
                # Replace main syslinux.cfg with localized version
                GRAFT=$(echo "$GRAFT" | sed "s|minios/boot/syslinux/syslinux\.cfg=$MINIOS/boot/syslinux/syslinux\.cfg|minios/boot/syslinux/syslinux.cfg=$LOCALIZED_CFG|")
            elif [ -f "$MINIOS/boot/syslinux/lang/en_US.cfg" ]; then
                information "$(gettext "Localized configuration not found for") $MENU_TYPE, $(gettext "using English")"
                GRAFT=$(echo "$GRAFT" | sed "s|minios/boot/syslinux/syslinux\.cfg=$MINIOS/boot/syslinux/syslinux\.cfg|minios/boot/syslinux/syslinux.cfg=$MINIOS/boot/syslinux/lang/en_US.cfg|")
            fi
        fi
    fi
    ;;
esac

# add all modules
for MOD in "${MODULES[@]}"; do
    if [ ! -e "$MOD" ]; then
        error "$(gettext "File does not exist: $MOD")"
        exit 3
    fi
    BAS="$(basename "$MOD")"
    if [[ $BAS =~ ^[0-9]{2}- ]]; then
        GRAFT="$GRAFT minios/$BAS=$MOD"
    else
        GRAFT="$GRAFT minios/modules/$BAS=$MOD"
    fi
done

run_with_spinner "$(gettext "Creating ISO work directory")" mkdir -p "$TEMP/minios/boot" "$TEMP/minios/modules" "$TEMP/minios/changes" "$TEMP/minios/scripts"

case "$BOOTLOADER_TYPE" in
"grub-only")
    run_with_spinner "$(gettext "Copying boot files (GRUB BIOS only)")" mkdir -p "$TEMP/minios/boot/grub/i386-pc"
    ;;
"syslinux-native")
    run_with_spinner "$(gettext "Copying boot files (SYSLINUX native)")" sh -c 'mkdir -p "$1/syslinux" && cp "$0/boot/syslinux/isolinux.bin" "$1/syslinux/" && cp "$0/boot/syslinux/isohdpfx.bin" "$1/syslinux/"' "$MINIOS" "$TEMP/minios/boot"
    ;;
"syslinux-grub")
    run_with_spinner "$(gettext "Copying boot files (SYSLINUX + GRUB)")" sh -c 'mkdir -p "$1/syslinux" && cp "$0/boot/syslinux/isolinux.bin" "$1/syslinux/" && cp "$0/boot/syslinux/isohdpfx.bin" "$1/syslinux/"' "$MINIOS" "$TEMP/minios/boot"
    ;;
*)
    # This should not happen as we already validated BOOTLOADER_TYPE above
    error "$(gettext "Internal error: invalid bootloader type for boot files")"
    exit 2
    ;;
esac

cd "$TEMP" || exit 4

PERCHIMG=$(mktemp --suffix=.img)
run_with_spinner "$(gettext "Creating temporary persistence image")" dd if=/dev/zero of="$PERCHIMG" bs=1M count=1
run_with_spinner "$(gettext "Formatting persistence image")" mkfs.ext2 -L persistence "$PERCHIMG"
# Set bootloader-specific parameters based on detected type
case "$BOOTLOADER_TYPE" in
"grub-only")
    # GRUB only parameters
    BIOS_BOOT_IMG="minios/boot/grub/i386-pc/eltorito.img"
    BIOS_BOOT_CATALOG="minios/boot/grub/boot.cat"
    BIOS_MBR_IMG="$MINIOS/boot/grub/i386-pc/boot_hybrid.img"
    BIOS_BOOT_PARAMS="-eltorito-catalog ${BIOS_BOOT_CATALOG}"
    ;;
"syslinux-grub"|"syslinux-native")
    # SYSLINUX/ISOLINUX parameters
    BIOS_BOOT_IMG="minios/boot/syslinux/isolinux.bin"
    BIOS_BOOT_CATALOG="minios/boot/syslinux/isolinux.boot"
    BIOS_MBR_IMG="$MINIOS/boot/syslinux/isohdpfx.bin"
    BIOS_BOOT_PARAMS="-eltorito-catalog ${BIOS_BOOT_CATALOG}"
    ;;
*)
    # This should not happen as we already validated BOOTLOADER_TYPE above
    error "$(gettext "Internal error: invalid bootloader type for ISO parameters")"
    exit 2
    ;;
esac

run_with_spinner "$(gettext "Generating ISO image")" xorriso \
    --as mkisofs \
    -iso-level 3 \
    -volid "${SYSTEMNAME^^}" \
    -A "$SYSTEMNAME" \
    -joliet -joliet-long -rational-rock \
    -eltorito-boot "${BIOS_BOOT_IMG}" \
    ${BIOS_BOOT_PARAMS} \
    -no-emul-boot \
    -boot-load-size 4 \
    -boot-info-table \
    -eltorito-alt-boot \
    -e "minios/boot/grub/efi64.img" \
    -no-emul-boot \
    -eltorito-alt-boot \
    -e "minios/boot/grub/efi32.img" \
    -no-emul-boot \
    --isohybrid-mbr "${BIOS_MBR_IMG}" \
    -append_partition 2 0x83 "$PERCHIMG" \
    -partition_cyl_align on \
    -partition_offset 16 \
    -part_like_isohybrid \
    -graft-points $GRAFT \
    -output "$TARGET" && SUCCESS="true"

run_with_spinner "$(gettext "Cleaning up temporary files")" rm -rf "$TEMP" "$PERCHIMG"

# Clean up temporary GRUB config if it was created
if [ -n "$TEMP_GRUB_CONFIG" ] && [ -e "$TEMP_GRUB_CONFIG" ]; then
    rm -f "$TEMP_GRUB_CONFIG"
fi

if [ "$SUCCESS" = "true" ]; then
    information "ISO successfully created: ${CYAN}$TARGET${ENDCOLOR}"
else
    error "$(gettext "Failed to create ISO image")"
    exit 1
fi
